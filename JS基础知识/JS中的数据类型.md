## number数字类型 `1.JS`
> 包含：常规数字、NAN
#### NaN：不是一个数字
> not a number：不是一个属，但它属于数字类型

NaN和任何值（包括自己）都不相等：NaN!=NaN,所以我们不能用相等的方式判断是否为有效数字

#### isNaN
> 检测一个值是否为非有效数字，如果不是有效数字返回TRUE，反之是有效数字返回FALSE

在使用isNaN进行检测的时候，首先会验证检测的值是否为有效数字，如果不是，先基于Number()这个方法，把值转换为数字类型，然后再检测

#### 把其他类型值转换为数字
- Number([val])
- parseInt/parseFloat([val],[进制])：也是转换为数字的方法，对于字符串来说，他是从左到右依次查找有效数字字符，直到遇到非有效数字字符，停止查找（不管后面是否还有数字，都不在找了），把找到的当作数字返回
- ==进行比较的时候，可能出现把其他类型值转换为数字

## string字符串数据类型 `2.js`
> 所有用单引号、双引号、反引号（撇 ES6模板字符串）包起来的都是字符串

#### 把其他类型值转换为字符串
- [val].toString()
- 字符串拼接

## boolean布尔数据类型值 `3.js`
> 只有两个值 true/false

#### 把其他类性值转换为布尔类型
> 只有 0、NaN、' '、null、undefined五个值转换为FALSE，其余都转换为TRUE（而且没有任何特殊的情况）

- Boolean([val])
- !/!!
- 条件判断

## null/undefined
> null和undefined都代表的是没有

- null：意料之中（一般都是开始不知道值，我们手动先设置为null，后期再给予赋值操作）
```javascript
let num = null; //=> let num = 0;一般最好用null作为初始的空值，因为零不是空值，它在栈内存中有自己的存储空间（占了位置）
...
num = 12;
```
- undefined：意料之外（不是我能决定的）
```javascript
let num; //=>创建一个变量没有赋值，默认值是undefined
...
num = 12；
```

## object对象数据类型-普通对象 `4.js`
> {[key1]:[value1],...[key2]:[value2]}任何一个对象都是由零到多组键值对（属性名：属性值）组成的（并且属性名不能重复）
- 获取属性名对应的属性值
- 设置属性名和属性值
- 删除属性名和属性值

> 数组是特殊的对象类型


## Math
> 数学函数：但是它不是一个函数，它是一个对象，对象中存储了很多操作数字的属性方法，因此被称为数学函数

```javascript
console.log(typeof Math);
console.dir(Math);

/*
 *
 *  Math={
 *      PI: 3.141592653589793
 *      abs: function abs()
 * }
 *
 * Math.abs();
 * Math.PI;
 */
```
#### Math中的常用方法 `13.js`
1. Math.abs([number value])
> 获取绝对值（绝对值永远是正数或者零）
2. Math.ceil / floor([number value])
> 把一个数向上取整 / 向下取整
3. Math.round([number value])
> 四舍五入
4. Math.max / min([val1],[val2],...)
> 获取一堆数中的最大值和最小值
5. Math.sqrt / pow()
> sqrt：给一个数开平方，pow：计算一个数的多少次幂
  - `必须记住`2的10次幂是1024
6. Math.random([number value])
> 获取0~1之间的随机小数

扩展：获取[n~m]之间的随机整数
> 包含n也包含m
> 
> n<m

```javascript
Math.round(Math.random()*(m-n)+n)
```
#### 数组及数组中的常用方法 `14.js`
> 数组是对象数据类型的，他属于特殊的对象类型

**数组中的常用方法**
- 方法的作用和含义
- 方法的实参（类型和含义）
- 方法的返回值
- 原来数组是否会发生改变
1. **实现数组增删改的方法**
> 这一部分都会修改原有的数组
- push
- unshift
- shift
- pop
- splice
2. **数组的查询和拼接**
> 这一部分原来数组不会改变
- slice
```javascript
//思考：关于数组克隆
//如果n/m为负数会怎样
//如果n>m会怎样
//如果是小数会怎样
//如果是非有效数字会怎样
//如果m或者n的值比最大索引还大会怎样
//思考：这种克隆叫做浅克隆，深克隆怎么处理
```
- concat
3. **把数组转换为字符串**
> 原有数组不变
- toString
- join
4. **验证数组中是否包含某一项**
- indexOf / lastIndexOf / includes
5. **数组的排序或者排列**
> 这几种方法会改变原数组
- reverse
- sort
6. **遍历数组中每一项的方法 `重中之重`**
- forEach
- map
- filter
- find
- reduce
- some
- every

#### 数组有关的案例
1. 数组去重 `15.js`
   - 数组塌陷问题


## 函数 function `9.js`
> 函数就是一个方法或者一个功能体，函数就是把实现某个功能的代码放到一起进行分装，以后想要操作实现这个功能，只需要把函数执行即可=>'封装'：减少页面中冗余代码，提高代码重复使用率（低耦合高内聚）

- **创建函数**
  + 形参
  > 执行的时候需要告诉函数参数是什么
  + 返回值return
  > 1.返回值应用场景：因为函数执行时，函数体内的变量在外面无法直接获取，因此想要使用函数内部的某些值就需要使用return返回。

  > 2.返回的一定是值，想在函数外获得函数的返回值，需要创建一个变量接收。

  > 3.函数默认的返回值是undefined

  > 4.函数体执行过程中遇到return，后面代码则不在执行了
- **执行函数**
  + 实参
- **arguments**
- **函数底层运行机制**
- ...

#### 创建函数
```javascript
//=>ES5老方式：普通函数
fucntion[函数名]([形参变量1,...]){
    // 函数体：基于JS完成需要实现的功能
    return [处理后的结果];
}
//执行函数
[函数名]([实参1],...);


//======ES5老方式：匿名函数======
// 匿名函数之表达式：把一个匿名函数本身作为值赋值给其他东西，这种函数一般不是手动触发执行，而是靠其他程序驱动触发执行（例如：触发某个事件的时候把函数执行）
document.body.onclick = function () {}

setTimeout(function () {}, 1000);//=> 设置定时器，1000ms后执行函数

//匿名函数之自执行函数：创建完一个匿名函数，紧接着就把当前函数加小括号执行
(function (n) { 
    //n = >100 
})(100);
```

#### 函数的深入理解

- 创建函数的过程：
1. 浏览器开辟一个栈内存，存储变量（函数名fn）和值（或空间地址）。
2. 由于函数是引用数据类型所以需要将函数中的函数体按照字符串数据类型存储到开辟的堆内存中（由于是按字符串格式存储，故而创建函数没有任何意义）
   

`创建函数，开辟的堆内存中存储的是函数体中的代码，但是是按照字符串存储的`

- 函数执行过程

1. 先把函数执行
2. 再把执行后的返回结果和函数外面创建的变量关联在一起（函数的返回值只看return。有return，return后面是啥返回值就是啥，没有就是undefined）

> 每一次函数执行的目的都是把函数体中的代码（先从字符串变为代码）执行 => 形成一个全新的私有栈内存

> AO和VO

#### arguments函数内置的实参集合
  1. 类数组集合，集合中存储着所有函数执行时，传递的实参信息
  2. 不论是否设置形参，arguments都存在
  3. 不论是否传递实参，arguments也都存在

  > arguments.callee：存储的是当前函数本身（一般不同的，JS严格模式下禁止使用）

  > `案例：`任意数求和（执行函数的时候，传递N个值来实现求和）
  1. 传递的实参的个数不固定
  2. 传递的值是否为有效数字不固定
  3. 结果是把传递得有效数字进行相加求和

#### arrow function：箭头函数
> 箭头函数没有arguments，但是箭头函数中有...：展开/剩余运算符

> 箭头函数中的this某些场景也是方便我们操作的



